<template>
  <q-page padding>
    <div class="q-pa-md">
      <div class="row items-center q-mb-md"><div class="col"><h5 class="q-my-none">{{ $t('nav.meterReadings') }}</h5></div><div class="col-auto"><q-btn color="primary" icon="add" label="Submit Reading" @click="showSubmitDialog = true" no-caps unelevated /></div></div>
      <q-card class="q-mb-md"><q-card-section><div class="row q-col-gutter-md"><div class="col-12 col-md-3"><q-select v-model="filters.complexId" :options="complexes" option-value="id" option-label="name" label="Complex" outlined dense clearable emit-value map-options @update:model-value="fetchReadings" /></div><div class="col-12 col-md-3"><q-select v-model="filters.unitId" :options="units" option-value="id" option-label="unitNumber" label="Unit" outlined dense clearable emit-value map-options @update:model-value="fetchReadings" /></div><div class="col-12 col-md-3"><q-select v-model="filters.meterType" :options="['Electricity', 'Water', 'Gas', 'Heating']" label="Meter Type" outlined dense clearable @update:model-value="fetchReadings" /></div><div class="col-12 col-md-3"><q-input v-model="filters.period" label="Period" outlined dense type="month" @update:model-value="fetchReadings" /></div></div></q-card-section></q-card>
      <q-card><q-table :rows="readings" :columns="columns" row-key="id" :loading="loading" :pagination="pagination" @request="onRequest" flat bordered><template v-slot:body-cell-consumption="props"><q-td :props="props"><q-badge color="info" :label="props.row.consumption + ' ' + props.row.unit" /></q-td></template><template v-slot:body-cell-actions="props"><q-td :props="props"><q-btn flat round dense icon="timeline" color="primary" @click="viewHistory(props.row)" /></q-td></template></q-table></q-card>
      <q-dialog v-model="showSubmitDialog" persistent><q-card style="min-width: 500px"><q-card-section><div class="text-h6">Submit Meter Reading</div></q-card-section><q-card-section><q-form @submit="submitReading" class="q-gutter-md"><q-select v-model="newReading.complexId" :options="complexes" option-value="id" option-label="name" label="Complex *" outlined emit-value map-options :rules="[val => !!val || 'Required']" @update:model-value="loadUnits" /><q-select v-model="newReading.unitId" :options="units" option-value="id" option-label="unitNumber" label="Unit *" outlined emit-value map-options :rules="[val => !!val || 'Required']" /><q-select v-model="newReading.meterType" :options="['Electricity', 'Water', 'Gas', 'Heating']" label="Meter Type *" outlined :rules="[val => !!val || 'Required']" /><q-input v-model.number="newReading.reading" type="number" label="Reading Value *" outlined suffix="kWh" :rules="[val => val > 0 || 'Required']" /><q-input v-model="newReading.readingDate" type="date" label="Reading Date *" outlined :rules="[val => !!val || 'Required']" /><q-input v-model="newReading.notes" label="Notes" outlined type="textarea" rows="2" /><div class="row q-gutter-md justify-end"><q-btn flat label="Cancel" color="grey" v-close-popup /><q-btn type="submit" label="Submit" color="primary" :loading="submitting" /></div></q-form></q-card-section></q-card></q-dialog>
    </div>
  </q-page>
</template>
<script>
import { defineComponent, ref, onMounted, computed } from 'vue'; import { useI18n } from 'vue-i18n'; import { useQuasar } from 'quasar'; import { meterReadingsAPI, complexesAPI, unitsAPI } from '../../api';
export default defineComponent({ name: 'MeterReadingsListPage', setup() { const { t } = useI18n(); const $q = useQuasar(); const loading = ref(false), submitting = ref(false), readings = ref([]), complexes = ref([]), units = ref([]), showSubmitDialog = ref(false); const filters = ref({ complexId: null, unitId: null, meterType: null, period: null }), pagination = ref({ sortBy: 'readingDate', descending: true, page: 1, rowsPerPage: 10, rowsNumber: 0 }); const newReading = ref({ complexId: null, unitId: null, meterType: '', reading: null, readingDate: new Date().toISOString().split('T')[0], notes: '' }); const columns = computed(() => [{ name: 'readingDate', label: 'Date', field: 'readingDate', align: 'left', sortable: true, format: val => new Date(val).toLocaleDateString() }, { name: 'complex', label: 'Complex', field: row => row.unit?.complex?.name, align: 'left' }, { name: 'unit', label: 'Unit', field: row => row.unit?.unitNumber, align: 'left' }, { name: 'meterType', label: 'Meter Type', field: 'meterType', align: 'left' }, { name: 'reading', label: 'Reading', field: 'reading', align: 'right' }, { name: 'consumption', label: 'Consumption', field: 'consumption', align: 'center' }, { name: 'actions', label: 'Actions', field: 'actions', align: 'center' }]); const fetchReadings = async (props = {}) => { loading.value = true; try { const { page, rowsPerPage, sortBy, descending } = props.pagination || pagination.value; const params = { page, limit: rowsPerPage, sortBy, order: descending ? 'desc' : 'asc', ...filters.value }; const response = await meterReadingsAPI.getAll(params); readings.value = response.data.data || []; pagination.value.page = response.data.page || 1; pagination.value.rowsPerPage = response.data.limit || 10; pagination.value.rowsNumber = response.data.total || 0; } catch (error) { $q.notify({ message: error.message, color: 'negative', icon: 'error' }); } finally { loading.value = false; } }; const fetchComplexes = async () => { try { const response = await complexesAPI.getAll({ limit: 100 }); complexes.value = response.data.data || []; } catch (error) { console.error('Failed', error); } }; const loadUnits = async () => { if (!newReading.value.complexId) return; try { const response = await unitsAPI.getAll({ complexId: newReading.value.complexId, limit: 100 }); units.value = response.data.data || []; } catch (error) { console.error('Failed', error); } }; const onRequest = (props) => { fetchReadings(props); }; const viewHistory = (reading) => { $q.notify({ message: 'History view coming soon', color: 'info' }); }; const submitReading = async () => { submitting.value = true; try { await meterReadingsAPI.create(newReading.value); $q.notify({ message: 'Reading submitted successfully', color: 'positive', icon: 'check' }); showSubmitDialog.value = false; newReading.value = { complexId: null, unitId: null, meterType: '', reading: null, readingDate: new Date().toISOString().split('T')[0], notes: '' }; await fetchReadings(); } catch (error) { $q.notify({ message: error.message, color: 'negative', icon: 'error' }); } finally { submitting.value = false; } }; onMounted(() => { fetchReadings(); fetchComplexes(); }); return { loading, submitting, readings, complexes, units, filters, pagination, columns, showSubmitDialog, newReading, onRequest, viewHistory, submitReading, loadUnits }; } });
</script>
